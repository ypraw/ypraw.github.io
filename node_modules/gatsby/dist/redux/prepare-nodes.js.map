{"version":3,"sources":["../../src/redux/prepare-nodes.js"],"names":["_","require","trackInlineObjectsInRootNode","store","getNullableType","getNamedType","withResolverContext","enhancedNodeCache","Map","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","awaitSiftField","fields","k","field","resolve","getState","schema","fieldName","returnType","type","undefined","resolveRecursive","siftFieldsObj","gqFields","Promise","all","keys","map","then","v","innerSift","innerGqConfig","innerType","innerListType","isObject","isFunction","getFields","isArray","item","resolvedFields","myNode","forEach","resolveNodes","nodes","typeName","firstOnly","fieldsToSift","gqlFields","resolvedNodesCache","nodesCacheKey","nodesLength","length","has","get","cacheKey","enhancedNodeGenerationPromise","resolvedNode","set","resolvedNodes","dispatch","payload","key","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst { trackInlineObjectsInRootNode } = require(`../db/node-tracking`)\nconst { store } = require(`../redux`)\nconst { getNullableType, getNamedType } = require(`graphql`)\nconst withResolverContext = require(`../schema/context`)\n\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\n/////////////////////////////////////////////////////////////////////\n// Resolve nodes\n/////////////////////////////////////////////////////////////////////\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    const { schema } = store.getState()\n    return field.resolve(node, {}, withResolverContext({}, schema), {\n      fieldName: k,\n      schema,\n      returnType: field.type,\n    })\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n// Resolves every field used in the node.\nfunction resolveRecursive(node, siftFieldsObj, gqFields) {\n  return Promise.all(\n    _.keys(siftFieldsObj).map(k =>\n      Promise.resolve(awaitSiftField(gqFields, node, k))\n        .then(v => {\n          const innerSift = siftFieldsObj[k]\n          const innerGqConfig = gqFields[k]\n\n          const innerType = getNullableType(innerGqConfig.type)\n          const innerListType = getNamedType(innerType)\n          if (_.isObject(innerSift) && v != null && innerType) {\n            if (_.isFunction(innerType.getFields)) {\n              // this is single object\n              return resolveRecursive(v, innerSift, innerType.getFields())\n            } else if (_.isArray(v) && _.isFunction(innerListType.getFields)) {\n              // this is array\n              return Promise.all(\n                v.map(item =>\n                  resolveRecursive(item, innerSift, innerListType.getFields())\n                )\n              )\n            }\n          }\n\n          return v\n        })\n        .then(v => [k, v])\n    )\n  ).then(resolvedFields => {\n    const myNode = {\n      ...node,\n    }\n    resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n    return myNode\n  })\n}\n\nfunction resolveNodes(nodes, typeName, firstOnly, fieldsToSift, gqlFields) {\n  const { resolvedNodesCache } = store.getState()\n  const nodesCacheKey = JSON.stringify({\n    // typeName + count being the same is a pretty good\n    // indication that the nodes are the same.\n    typeName,\n    firstOnly,\n    nodesLength: nodes.length,\n    ...fieldsToSift,\n  })\n  if (resolvedNodesCache.has(nodesCacheKey)) {\n    return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n  } else {\n    return Promise.all(\n      nodes.map(node => {\n        const cacheKey = enhancedNodeCacheId({\n          node,\n          args: fieldsToSift,\n        })\n        if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n          return Promise.resolve(enhancedNodeCache.get(cacheKey))\n        } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n          return enhancedNodePromiseCache.get(cacheKey)\n        }\n\n        const enhancedNodeGenerationPromise = new Promise(resolve => {\n          resolveRecursive(node, fieldsToSift, gqlFields).then(resolvedNode => {\n            trackInlineObjectsInRootNode(resolvedNode)\n            if (cacheKey) {\n              enhancedNodeCache.set(cacheKey, resolvedNode)\n            }\n            resolve(resolvedNode)\n          })\n        })\n        enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n        return enhancedNodeGenerationPromise\n      })\n    ).then(resolvedNodes => {\n      store.dispatch({\n        type: `SET_RESOLVED_NODES`,\n        payload: {\n          key: nodesCacheKey,\n          nodes: resolvedNodes,\n        },\n      })\n      return resolvedNodes\n    })\n  }\n}\n\nmodule.exports = {\n  resolveNodes,\n  resolveRecursive,\n}\n"],"file":"prepare-nodes.js"}