{"version":3,"sources":["../../../src/redux/actions/restricted.js"],"names":["report","require","actions","addThirdPartySchema","schema","plugin","traceId","type","payload","createTypes","types","withDeprecationWarning","actionName","action","api","allowedIn","args","warn","map","a","join","withErrorMessage","error","nodeAPIs","Object","keys","ALLOWED_IN","DEPRECATED_IN","set","availableActionsByAPI","mapAvailableActionsToAPIs","restrictions","actionNames","forEach","deprecatedIn","forbiddenIn","filter","includes","module","exports"],"mappings":"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","sourcesContent":["// @flow\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport type { Plugin } from \"./types\"\n\nconst actions = {}\n\n/**\n * Add a third-party schema to be merged into main schema. Schema has to be a\n * graphql-js GraphQLSchema object.\n *\n * This schema is going to be merged as-is. This can easily break the main\n * Gatsby schema, so it's user's responsibility to make sure it doesn't happen\n * (by eg namespacing the schema).\n *\n * @availableIn [sourceNodes]\n *\n * @param {Object} $0\n * @param {GraphQLSchema} $0.schema GraphQL schema to add\n */\nactions.addThirdPartySchema = (\n  { schema }: { schema: GraphQLSchema },\n  plugin: Plugin,\n  traceId?: string\n) => {\n  return {\n    type: `ADD_THIRD_PARTY_SCHEMA`,\n    plugin,\n    traceId,\n    payload: schema,\n  }\n}\n\nimport type GatsbyGraphQLType from \"../../schema/types/type-builders\"\n/**\n * Add type definitions to the GraphQL schema.\n *\n * @availableIn [sourceNodes]\n *\n * @param {string | GraphQLOutputType | GatsbyGraphQLType | string[] | GraphQLOutputType[] | GatsbyGraphQLType[]} types Type definitions\n *\n * Type definitions can be provided either as\n * [`graphql-js` types](https://graphql.org/graphql-js/), in\n * [GraphQL schema definition language (SDL)](https://graphql.org/learn/)\n * or using Gatsby Type Builders available on the `schema` API argument.\n *\n * Things to note:\n * * type definitions targeting node types, i.e. `MarkdownRemark` and others\n *   added in `sourceNodes` or `onCreateNode` APIs, need to implement the\n *   `Node` interface. Interface fields will be added automatically, but it\n *   is mandatory to label those types with `implements Node`.\n * * by default, explicit type definitions from `createTypes` will be merged\n *   with inferred field types, and default field resolvers for `Date` (which\n *   adds formatting options) and `File` (which resolves the field value as\n *   a `relativePath` foreign-key field) are added. This behavior can be\n *   customised with `@infer`, `@dontInfer` directives or extensions. Fields\n *   may be assigned resolver (and other option like args) with additional\n *   directives. Currently `@dateformat`, `@link` and `@fileByRelativePath` are\n *   available.\n *\n *\n * Schema customization controls:\n * * `@infer` - run inference on the type and add fields that don't exist on the\n * defined type to it.\n * * `@dontInfer` - don't run any inference on the type\n *\n * Extensions to add resolver options:\n * * `@dateformat` - add date formatting arguments. Accepts `formatString` and\n *   `locale` options that sets the defaults for this field\n * * `@link` - connect to a different Node. Arguments `by` and `from`, which\n *   define which field to compare to on a remote node and which field to use on\n *   the source node\n * * `@fileByRelativePath` - connect to a File node. Same arguments. The\n *   difference from link is that this normalizes the relative path to be\n *   relative from the path where source node is found.\n * * `proxy` - in case the underlying node data contains field names with\n *   characters that are invalid in GraphQL, `proxy` allows to explicitly\n *   proxy those properties to fields with valid field names. Takes a `from` arg.\n *\n *\n * @example\n * exports.sourceNodes = ({ actions }) => {\n *   const { createTypes } = actions\n *   const typeDefs = `\n *     \"\"\"\n *     Markdown Node\n *     \"\"\"\n *     type MarkdownRemark implements Node @infer {\n *       frontmatter: Frontmatter!\n *     }\n *\n *     \"\"\"\n *     Markdown Frontmatter\n *     \"\"\"\n *     type Frontmatter @infer {\n *       title: String!\n *       author: AuthorJson! @link\n *       date: Date! @dateformat\n *       published: Boolean!\n *       tags: [String!]!\n *     }\n *\n *     \"\"\"\n *     Author information\n *     \"\"\"\n *     # Does not include automatically inferred fields\n *     type AuthorJson implements Node @dontInfer {\n *       name: String!\n *       birthday: Date! @dateformat(locale: \"ru\")\n *     }\n *   `\n *   createTypes(typeDefs)\n * }\n *\n * // using Gatsby Type Builder API\n * exports.sourceNodes = ({ actions, schema }) => {\n *   const { createTypes } = actions\n *   const typeDefs = [\n *     schema.buildObjectType({\n *       name: 'MarkdownRemark',\n *       fields: {\n *         frontmatter: 'Frontmatter!'\n *       },\n *       interfaces: ['Node'],\n *       extensions: {\n *         infer: true,\n *       },\n *     }),\n *     schema.buildObjectType({\n *       name: 'Frontmatter',\n *       fields: {\n *         title: {\n *           type: 'String!',\n *           resolve(parent) {\n *             return parent.title || '(Untitled)'\n *           }\n *         },\n *         author: {\n *           type: 'AuthorJson'\n *           extensions: {\n *             link: {},\n *           },\n *         }\n *         date: {\n *           type: 'Date!'\n *           extensions: {\n *             dateformat: {},\n *           },\n *         },\n *         published: 'Boolean!',\n *         tags: '[String!]!',\n *       }\n *     }),\n *     schema.buildObjectType({\n *       name: 'AuthorJson',\n *       fields: {\n *         name: 'String!'\n *         birthday: {\n *           type: 'Date!'\n *           extensions: {\n *             dateformat: {\n *               locale: 'ru',\n *             },\n *           },\n *         },\n *       },\n *       interfaces: ['Node'],\n *       extensions: {\n *         infer: false,\n *       },\n *     }),\n *   ]\n *   createTypes(typeDefs)\n * }\n */\nactions.createTypes = (\n  types:\n    | string\n    | GraphQLOutputType\n    | GatsbyGraphQLType\n    | Array<string | GraphQLOutputType | GatsbyGraphQLType>,\n  plugin: Plugin,\n  traceId?: string\n) => {\n  return {\n    type: `CREATE_TYPES`,\n    plugin,\n    traceId,\n    payload: types,\n  }\n}\n\nconst withDeprecationWarning = (actionName, action, api, allowedIn) => (\n  ...args\n) => {\n  report.warn(\n    `Calling \\`${actionName}\\` in the \\`${api}\\` API is deprecated. ` +\n      `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n  )\n  return action(...args)\n}\n\nconst withErrorMessage = (actionName, api, allowedIn) => () =>\n  // return a thunk that does not dispatch anything\n  () => {\n    report.error(\n      `\\`${actionName}\\` is not available in the \\`${api}\\` API. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n  }\n\nconst nodeAPIs = Object.keys(require(`../../utils/api-node-docs`))\n\nconst ALLOWED_IN = `ALLOWED_IN`\nconst DEPRECATED_IN = `DEPRECATED_IN`\n\nconst set = (availableActionsByAPI, api, actionName, action) => {\n  availableActionsByAPI[api] = availableActionsByAPI[api] || {}\n  availableActionsByAPI[api][actionName] = action\n}\n\nconst mapAvailableActionsToAPIs = restrictions => {\n  const availableActionsByAPI = {}\n\n  const actionNames = Object.keys(restrictions)\n  actionNames.forEach(actionName => {\n    const action = actions[actionName]\n\n    const allowedIn = restrictions[actionName][ALLOWED_IN]\n    allowedIn.forEach(api =>\n      set(availableActionsByAPI, api, actionName, action)\n    )\n\n    const deprecatedIn = restrictions[actionName][DEPRECATED_IN]\n    deprecatedIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withDeprecationWarning(actionName, action, api, allowedIn)\n      )\n    )\n\n    const forbiddenIn = nodeAPIs.filter(\n      api => ![...allowedIn, ...deprecatedIn].includes(api)\n    )\n    forbiddenIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withErrorMessage(actionName, api, allowedIn)\n      )\n    )\n  })\n\n  return availableActionsByAPI\n}\n\nconst availableActionsByAPI = mapAvailableActionsToAPIs({\n  createTypes: {\n    [ALLOWED_IN]: [`sourceNodes`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n  addThirdPartySchema: {\n    [ALLOWED_IN]: [`sourceNodes`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n})\n\nmodule.exports = { actions, availableActionsByAPI }\n"],"file":"restricted.js"}