{"version":3,"sources":["../../../src/redux/reducers/inference-metadata.js"],"names":["omit","require","addNode","deleteNode","ignore","NodeInterfaceFields","typesWithoutInference","ignoredFields","Set","module","exports","state","action","type","typeDefs","Array","isArray","payload","ignoredTypes","reduce","forEach","node","oldNode","internal","addedField","previousFields","fields","dirty","fullNodes","Object","keys"],"mappings":"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","sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nconst { omit } = require(`lodash`)\nconst {\n  addNode,\n  deleteNode,\n  ignore,\n} = require(`../../schema/infer/inference-metadata`)\nconst { NodeInterfaceFields } = require(`../../schema/types/node-interface`)\nconst { typesWithoutInference } = require(`../../schema/types/type-defs`)\n\nconst ignoredFields = new Set([\n  ...NodeInterfaceFields,\n  `$loki`,\n  `__gatsby_resolved`,\n])\n\nmodule.exports = (state = {}, action) => {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      return {}\n\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload]\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, [])\n      ignoredTypes.forEach(type => {\n        state[type] = ignore(state[type])\n      })\n      return state\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action\n      const { type } = node.internal\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || { ignoredFields }, oldNode)\n      }\n      state[type] = addNode(state[type] || { ignoredFields }, node)\n      return state\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) return state\n      const { type } = node.internal\n      state[type] = deleteNode(state[type] || { ignoredFields }, node)\n      return state\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action\n      const { type } = node.internal\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField])\n      state[type] = deleteNode(state[type], { fields: previousFields })\n      state[type] = addNode(state[type], { fields: node.fields })\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal\n      state[type].dirty = true\n      return state\n    }\n\n    // Deprecated, will be removed in Gatsby v3.\n    case `DELETE_NODES`: {\n      const { fullNodes } = action\n      fullNodes.forEach(node => {\n        const { type } = node.internal\n        state[type] = deleteNode(state[type] || { ignoredFields }, node)\n      })\n      return state\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach(type => {\n        state[type].dirty = false\n      })\n      return state\n    }\n\n    default:\n      return state\n  }\n}\n"],"file":"inference-metadata.js"}