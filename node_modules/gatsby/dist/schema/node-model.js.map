{"version":3,"sources":["../../src/schema/node-model.js"],"names":["_","require","isAbstractType","GraphQLOutputType","GraphQLUnionType","invariant","LocalNodeModel","constructor","schema","nodeStore","createPageDependency","path","getNodeById","args","pageDependencies","id","type","node","result","nodeTypeNames","toNodeTypeNames","includes","internal","trackPageDependencies","getNodesByIds","ids","nodes","Array","isArray","map","filter","Boolean","length","getAllNodes","getNodes","reduce","acc","typeName","concat","getNodesByType","runQuery","query","firstOnly","gqlType","getType","queryResult","queryArgs","getTypes","findRootNodeAncestor","obj","predicate","fullDependencies","connectionType","connection","nodeId","isPlainObject","getNode","gqlTypeName","possibleTypes","getPossibleTypes","getInterfaces","some","iface","name","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst {\n  isAbstractType,\n  GraphQLOutputType,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\n\ntype IDOrNode = string | { id: string }\ntype TypeOrTypeName = string | GraphQLOutputType\n\n/**\n * Optional page dependency information.\n *\n * @typedef {Object} PageDependencies\n * @property {string} path The path of the page that depends on the retrieved nodes' data\n * @property {string} [connectionType] Mark this dependency as a connection\n */\ninterface PageDependencies {\n  path: string;\n  connectionType?: string;\n}\n\ninterface QueryArguments {\n  type: TypeOrTypeName;\n  query: { filter: Object, sort?: Object, skip?: number, limit?: number };\n  firstOnly?: boolean;\n}\n\nexport interface NodeModel {\n  getNodeById(\n    { id: IDOrNode, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): any | null;\n  getNodesByIds(\n    { ids: Array<IDOrNode>, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  getAllNodes(\n    { type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  runQuery(\n    args: QueryArguments,\n    pageDependencies?: PageDependencies\n  ): Promise<any>;\n  getTypes(): Array<string>;\n  trackPageDependencies<nodeOrNodes: Node | Node[]>(\n    result: nodeOrNodes,\n    pageDependencies?: PageDependencies\n  ): nodesOrNodes;\n}\n\nclass LocalNodeModel {\n  constructor({ schema, nodeStore, createPageDependency, path }) {\n    this.schema = schema\n    this.nodeStore = nodeStore\n    this.createPageDependency = createPageDependency\n    this.path = path\n  }\n\n  /**\n   * Get a node from the store by ID and optional type.\n   *\n   * @param {Object} args\n   * @param {string} args.id ID of the requested node\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {(Node|null)}\n   */\n  getNodeById(args, pageDependencies) {\n    const { id, type } = args || {}\n\n    const node = getNodeById(this.nodeStore, id)\n\n    let result\n    if (!node) {\n      result = null\n    } else if (!type) {\n      result = node\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodeTypeNames.includes(node.internal.type) ? node : null\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get nodes from the store by IDs and optional type.\n   *\n   * @param {Object} args\n   * @param {string[]} args.ids IDs of the requested nodes\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getNodesByIds(args, pageDependencies) {\n    const { ids, type } = args || {}\n\n    const nodes = Array.isArray(ids)\n      ? ids.map(id => getNodeById(this.nodeStore, id)).filter(Boolean)\n      : []\n\n    let result\n    if (!nodes.length || !type) {\n      result = nodes\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodes.filter(node => nodeTypeNames.includes(node.internal.type))\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get all nodes in the store, or all nodes of a specified type. Note that\n   * this doesn't add tracking to all the nodes, unless pageDependencies are\n   * passed.\n   *\n   * @param {Object} args\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getAllNodes(args, pageDependencies) {\n    const { type } = args || {}\n\n    let result\n    if (!type) {\n      result = this.nodeStore.getNodes()\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      const nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n      result = nodes.filter(Boolean)\n    }\n\n    if (pageDependencies) {\n      return this.trackPageDependencies(result, pageDependencies)\n    } else {\n      return result\n    }\n  }\n\n  /**\n   * Get nodes of a type matching the specified query.\n   *\n   * @param {Object} args\n   * @param {Object} args.query Query arguments (`filter`, `sort`, `limit`, `skip`)\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {boolean} [args.firstOnly] If true, return only first match\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Promise<Node[]>}\n   */\n  async runQuery(args, pageDependencies) {\n    const { query, firstOnly, type } = args || {}\n\n    // We don't support querying union types (yet?), because the combined types\n    // need not have any fields in common.\n    const gqlType = typeof type === `string` ? this.schema.getType(type) : type\n    invariant(\n      !(gqlType instanceof GraphQLUnionType),\n      `Querying GraphQLUnion types is not supported.`\n    )\n\n    // We provide nodes in case of abstract types, because `run-sift` should\n    // only need to know about node types in the store.\n    let nodes\n    const nodeTypeNames = toNodeTypeNames(this.schema, gqlType)\n    if (nodeTypeNames.length > 1) {\n      nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n    }\n\n    const queryResult = await this.nodeStore.runQuery({\n      queryArgs: query,\n      firstOnly,\n      gqlType,\n      nodes,\n    })\n\n    let result = queryResult\n    if (args.firstOnly) {\n      if (result && result.length > 0) {\n        result = result[0]\n      } else {\n        result = null\n      }\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get the names of all node types in the store.\n   *\n   * @returns {string[]}\n   */\n  getTypes() {\n    return this.nodeStore.getTypes()\n  }\n\n  /**\n   * Get the root ancestor node for an object's parent node, or its first\n   * ancestor matching a specified condition.\n   *\n   * @param {(Object|Array)} obj An object belonging to a Node, or a Node object\n   * @param {Function} [predicate] Optional condition to match\n   * @returns {(Node|null)}\n   */\n  findRootNodeAncestor(obj, predicate) {\n    return this.nodeStore.findRootNodeAncestor(obj, predicate)\n  }\n\n  /**\n   * Given a result, that's either a single node or an array of them, track them\n   * using pageDependencies. Defaults to tracking according to current resolver\n   * path. Returns the result back.\n   *\n   * @param {Node | Node[]} result\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node | Node[]}\n   */\n  trackPageDependencies(result, pageDependencies) {\n    const fullDependencies = {\n      path: this.path,\n      ...(pageDependencies || {}),\n    }\n    const { path, connectionType } = fullDependencies\n    if (path) {\n      if (connectionType) {\n        this.createPageDependency({ path, connection: connectionType })\n      } else {\n        const nodes = Array.isArray(result) ? result : [result]\n        nodes\n          .filter(Boolean)\n          .map(node => this.createPageDependency({ path, nodeId: node.id }))\n      }\n    }\n\n    return result\n  }\n}\n\nconst getNodeById = (nodeStore, id) => {\n  // This is for cases when the `id` has already been resolved\n  // to a full Node for the input filter, and is also in the selection\n  // set. E.g. `{ foo(parent: { id: { eq: 1 } } ) { parent { id } } }`.\n  if (_.isPlainObject(id) && id.id) {\n    return id\n  }\n  return id != null ? nodeStore.getNode(id) : null\n}\n\nconst toNodeTypeNames = (schema, gqlTypeName) => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType) return []\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nmodule.exports = {\n  LocalNodeModel,\n}\n"],"file":"node-model.js"}