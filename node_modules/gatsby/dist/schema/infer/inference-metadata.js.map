{"version":3,"sources":["../../../src/schema/infer/inference-metadata.js"],"names":["groupBy","isEqual","require","is32BitInteger","looksLikeADate","getType","value","key","Date","String","Array","isArray","length","includes","Object","keys","updateValueDescriptor","nodeId","operation","descriptor","typeName","delta","typeInfo","total","dirty","first","undefined","props","forEach","propDescriptor","propDirty","item","itemDescriptor","itemDirty","nodes","empty","example","mergeObjectKeys","obj","other","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","array","object","every","prop","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","metadata","ignored","fieldMap","structureChanged","field","valueStructureChanged","id","ignore","set","addNode","deleteNode","addNodes","reduce","isMixedNumber","float","int","isMixOfDateAndString","date","string","hasOnlyEmptyStrings","type","resolveWinnerType","candidates","prepareConflictExamples","isArrayItem","typeNameMapper","reportedValueMapper","listOfUnion","getExampleObject","itemValue","buildExampleValue","conflictingTypes","groups","map","join","typeConflictReporter","path","conflicts","addConflict","exampleItemValue","hasKeys","result","acc","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields","module","exports"],"mappings":"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","sourcesContent":["/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Metadata structure\n\n```javascript\ntype TypeMetadata = {\n  total?: number,\n  ignored?: boolean,\n  ignoredFields?: Set<string>,\n  fieldMap?: { [string]: ValueDescriptor },\n  typeName?: string,\n  dirty?: boolean, // tracks structural changes only\n}\n\ntype Count = number\ntype NodeId = string\n\ntype ValueDescriptor = {\n  int?: { total: Count, first: NodeId, example: number },\n  float?: { total: Count, first: NodeId, example: number },\n  date?: { total: Count, first: NodeId, example: string },\n  string?: { total: Count, first: NodeId, example: string, empty: Count },\n  boolean?: { total: Count, first: NodeId, example: boolean },\n  array?: { total: Count, first: NodeId, item: ValueDescriptor },\n  listOfUnion?: { total: Count, first: NodeId, nodes: { [NodeId]: Count } },\n  object?: { total: 0, first: NodeId, props: { [string]: ValueDescriptor } },\n}\n```\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nconst { groupBy, isEqual } = require(`lodash`)\nconst is32BitInteger = require(`./is-32-bit-integer`)\nconst { looksLikeADate } = require(`../types/date`)\n\nconst getType = (value, key) => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `listOfUnion` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      return `null`\n  }\n}\n\nconst updateValueDescriptor = ({\n  nodeId,\n  key,\n  value,\n  operation = `add`,\n  descriptor = {},\n}) => {\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return [descriptor, false]\n  }\n\n  const delta = operation === `del` ? -1 : 1\n  const typeInfo = descriptor[typeName] || { total: 0 }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  let dirty =\n    typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    typeInfo.first = typeInfo.first || nodeId\n  } else if (operation === `del`) {\n    typeInfo.first =\n      typeInfo.first === nodeId || typeInfo.total === 0\n        ? undefined\n        : typeInfo.first\n  }\n\n  switch (typeName) {\n    case `object`: {\n      const { props = {} } = typeInfo\n      Object.keys(value).forEach(key => {\n        const [propDescriptor, propDirty] = updateValueDescriptor({\n          nodeId,\n          key,\n          value: value[key],\n          operation,\n          descriptor: props[key],\n        })\n        props[key] = propDescriptor\n        dirty = dirty || propDirty\n      })\n      typeInfo.props = props\n      break\n    }\n    case `array`: {\n      value.forEach(item => {\n        const [itemDescriptor, itemDirty] = updateValueDescriptor({\n          nodeId,\n          descriptor: typeInfo.item,\n          operation,\n          value: item,\n          key,\n        })\n        typeInfo.item = itemDescriptor\n        dirty = dirty || itemDirty\n      })\n      break\n    }\n    case `listOfUnion`: {\n      const { nodes = {} } = typeInfo\n      value.forEach(nodeId => {\n        nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n        // Treat any new related node addition or removal as a structural change\n        // FIXME: this will produce false positives as this node can be\n        //  of the same type as another node already in the map (but we don't know it)\n        dirty = dirty || nodes[nodeId] === 0 || nodes[nodeId] === 1\n      })\n      typeInfo.nodes = nodes\n      break\n    }\n    case `string`: {\n      if (value === ``) {\n        const { empty = 0 } = typeInfo\n        typeInfo.empty = empty + delta\n      }\n      typeInfo.example =\n        typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n      break\n    }\n    default:\n      typeInfo.example =\n        typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n      break\n  }\n  descriptor[typeName] = typeInfo\n  return [descriptor, dirty]\n}\n\nconst mergeObjectKeys = (obj, other) => {\n  const props = Object.keys(obj)\n  const otherProps = Object.keys(other)\n  return [...new Set(props.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (descriptor, otherDescriptor) => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  // Empty are equal\n  if (types.length === 0 && otherTypes.length === 0) {\n    return true\n  }\n  // Conflicting and non-matching types are not equal\n  // TODO: consider descriptors with equal conflicts as equal?\n  if (types.length > 1 || otherTypes.length > 1 || types[0] !== otherTypes[0]) {\n    return false\n  }\n  switch (types[0]) {\n    case `array`:\n      return descriptorsAreEqual(\n        descriptor.array.item,\n        otherDescriptor.array.item\n      )\n    case `object`: {\n      const props = mergeObjectKeys(\n        descriptor.object.props,\n        otherDescriptor.object.props\n      )\n      return props.every(prop =>\n        descriptorsAreEqual(\n          descriptor.object.props[prop],\n          otherDescriptor.object.props[prop]\n        )\n      )\n    }\n    case `listOfUnion`: {\n      return isEqual(descriptor.nodes, otherDescriptor.nodes)\n    }\n    default:\n      return true\n  }\n}\n\nconst nodeFields = (node, ignoredFields = new Set()) =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (metadata = {}, operation, node) => {\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {}, dirty = false } = metadata\n\n  let structureChanged = false\n  nodeFields(node, ignoredFields).forEach(field => {\n    const [descriptor, valueStructureChanged] = updateValueDescriptor({\n      nodeId: node.id,\n      key: field,\n      value: node[field],\n      operation,\n      descriptor: fieldMap[field],\n    })\n    fieldMap[field] = descriptor\n    structureChanged = structureChanged || valueStructureChanged\n  })\n  metadata.fieldMap = fieldMap\n  metadata.dirty = dirty || structureChanged\n  return metadata\n}\n\nconst ignore = (metadata = {}, set = true) => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst addNode = (metadata, node) => updateTypeMetadata(metadata, `add`, node)\nconst deleteNode = (metadata, node) => updateTypeMetadata(metadata, `del`, node)\nconst addNodes = (metadata, nodes) => nodes.reduce(addNode, metadata)\n\nconst isMixedNumber = ({ float, int }) =>\n  float && float.total > 0 && int && int.total > 0\n\nconst isMixOfDateAndString = ({ date, string }) =>\n  date && date.total > 0 && string && string.total > 0\n\nconst hasOnlyEmptyStrings = ({ string }) =>\n  string && string.empty === string.total\n\nconst possibleTypes = (descriptor = {}) =>\n  Object.keys(descriptor).filter(type => descriptor[type].total > 0)\n\nconst resolveWinnerType = descriptor => {\n  const candidates = possibleTypes(descriptor)\n  if (candidates.length === 1) {\n    return [candidates[0]]\n  }\n  if (candidates.length === 2 && isMixedNumber(descriptor)) {\n    return [`float`]\n  }\n  if (candidates.length === 2 && isMixOfDateAndString(descriptor)) {\n    return [hasOnlyEmptyStrings(descriptor) ? `date` : `string`]\n  }\n  if (candidates.length > 1) {\n    return [`null`, true]\n  }\n  return [`null`]\n}\n\nconst prepareConflictExamples = (descriptor, isArrayItem) => {\n  const typeNameMapper = typeName => {\n    if (typeName === `listOfUnion`) {\n      return `[string]`\n    }\n    return [`float`, `int`].includes(typeName) ? `number` : typeName\n  }\n  const reportedValueMapper = typeName => {\n    if (typeName === `listOfUnion`) {\n      const { nodes } = descriptor.listOfUnion\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n    if (typeName === `object`) {\n      return getExampleObject({ typeName, fieldMap: descriptor.object.props })\n    }\n    if (typeName === `array`) {\n      const itemValue = buildExampleValue({\n        descriptor: descriptor.array.item,\n        isArrayItem: true,\n      })\n      return itemValue === null || itemValue === undefined ? [] : [itemValue]\n    }\n    return descriptor[typeName].example\n  }\n  const conflictingTypes = possibleTypes(descriptor)\n\n  if (isArrayItem) {\n    // Differentiate conflict examples by node they were first seen in.\n    // See Caveats section in the header of this file\n    const groups = groupBy(\n      conflictingTypes,\n      type => descriptor[type].first || ``\n    )\n    return Object.keys(groups).map(nodeId => {\n      return {\n        type: `[${groups[nodeId].map(typeNameMapper).join(`,`)}]`,\n        value: groups[nodeId].map(reportedValueMapper),\n      }\n    })\n  }\n\n  return conflictingTypes.map(type => {\n    return {\n      type: typeNameMapper(type),\n      value: reportedValueMapper(type),\n    }\n  })\n}\n\nconst buildExampleValue = ({\n  descriptor,\n  typeConflictReporter,\n  isArrayItem = false,\n  path = ``,\n}) => {\n  const [type, conflicts = false] = resolveWinnerType(descriptor)\n\n  if (conflicts && typeConflictReporter) {\n    typeConflictReporter.addConflict(\n      path,\n      prepareConflictExamples(descriptor, isArrayItem)\n    )\n  }\n\n  const typeInfo = descriptor[type]\n\n  switch (type) {\n    case `null`:\n      return null\n\n    case `date`:\n    case `string`: {\n      if (isMixOfDateAndString(descriptor)) {\n        return hasOnlyEmptyStrings(descriptor) ? `1978-09-26` : `String`\n      }\n      return typeInfo.example\n    }\n\n    case `array`: {\n      const { item } = typeInfo\n      const exampleItemValue = item\n        ? buildExampleValue({\n            descriptor: item,\n            isArrayItem: true,\n            typeConflictReporter,\n            path,\n          })\n        : null\n      return exampleItemValue === null ? null : [exampleItemValue]\n    }\n\n    case `listOfUnion`: {\n      const { nodes = {} } = typeInfo\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n\n    case `object`: {\n      const { props } = typeInfo\n      let hasKeys = false\n      const result = {}\n      Object.keys(props).forEach(prop => {\n        const value = buildExampleValue({\n          descriptor: typeInfo.props[prop],\n          typeConflictReporter,\n          path: `${path}.${prop}`,\n        })\n        if (value !== null) {\n          hasKeys = true\n          result[prop] = value\n        }\n      }, {})\n      return hasKeys ? result : null\n    }\n\n    default:\n      return typeInfo.example\n  }\n}\n\nconst getExampleObject = ({ fieldMap = {}, typeName, typeConflictReporter }) =>\n  Object.keys(fieldMap).reduce((acc, key) => {\n    const value = buildExampleValue({\n      path: `${typeName}.${key}`,\n      descriptor: fieldMap[key],\n      typeConflictReporter,\n    })\n    if (key && value !== null) {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\nconst isEmpty = ({ fieldMap }) =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = typeMetadata => typeMetadata.total > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n) => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nmodule.exports = {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  getExampleObject,\n}\n"],"file":"inference-metadata.js"}