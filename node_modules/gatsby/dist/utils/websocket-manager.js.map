{"version":3,"sources":["../../src/utils/websocket-manager.js"],"names":["path","require","store","fs","pageDataUtil","getCachedPageData","pagePath","directory","getState","program","publicDir","join","pageData","read","result","id","err","console","log","undefined","getCachedStaticQueryResults","resultsMap","cachedStaticQueryResults","Map","staticQueryComponents","forEach","staticQueryComponent","has","hash","filePath","fileResult","readFileSync","componentPath","set","JSON","parse","getRoomNameFromPath","WebsocketManager","constructor","isInitialised","activePaths","Set","pageResults","staticQueryResults","errors","init","bind","getSocket","emitPageData","emitStaticQueryData","emitError","server","programDir","websocket","on","s","activePath","send","type","payload","message","errorID","leaveRoom","leave","leftRoom","sockets","adapter","rooms","length","delete","getDataForPath","why","get","add","data","manager","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst path = require(`path`)\nconst { store } = require(`../redux`)\nconst fs = require(`fs`)\nconst pageDataUtil = require(`../utils/page-data`)\n\ntype QueryResult = {\n  id: string,\n  result: object,\n}\n\ntype QueryResultsMap = Map<string, QueryResult>\n\n/**\n * Get cached page query result for given page path.\n * @param {string} pagePath Path to a page.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedPageData = async (\n  pagePath: string,\n  directory: string\n): QueryResult => {\n  const { program } = store.getState()\n  const publicDir = path.join(program.directory, `public`)\n  try {\n    const pageData = await pageDataUtil.read({ publicDir }, pagePath)\n    return {\n      result: pageData.result,\n      id: pagePath,\n    }\n  } catch (err) {\n    console.log(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n    return undefined\n  }\n}\n\n/**\n * Get cached StaticQuery results for components that Gatsby didn't run query yet.\n * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedStaticQueryResults = (\n  resultsMap: QueryResultsMap,\n  directory: string\n): QueryResultsMap => {\n  const cachedStaticQueryResults = new Map()\n  const { staticQueryComponents } = store.getState()\n  staticQueryComponents.forEach(staticQueryComponent => {\n    // Don't read from file if results were already passed from query runner\n    if (resultsMap.has(staticQueryComponent.hash)) return\n    const filePath = path.join(\n      directory,\n      `public`,\n      `static`,\n      `d`,\n      `${staticQueryComponent.hash}.json`\n    )\n    const fileResult = fs.readFileSync(filePath, `utf-8`)\n    if (fileResult === `undefined`) {\n      console.log(\n        `Error loading a result for the StaticQuery in \"${\n          staticQueryComponent.componentPath\n        }\". Query was not run and no cached result was found.`\n      )\n      return\n    }\n    cachedStaticQueryResults.set(staticQueryComponent.hash, {\n      result: JSON.parse(fileResult),\n      id: staticQueryComponent.hash,\n    })\n  })\n  return cachedStaticQueryResults\n}\n\nconst getRoomNameFromPath = (path: string): string => `path-${path}`\n\nclass WebsocketManager {\n  pageResults: QueryResultsMap\n  staticQueryResults: QueryResultsMap\n  errors: Map<string, QueryResult>\n  isInitialised: boolean\n  activePaths: Set<string>\n  programDir: string\n\n  constructor() {\n    this.isInitialised = false\n    this.activePaths = new Set()\n    this.pageResults = new Map()\n    this.staticQueryResults = new Map()\n    this.errors = new Map()\n    // this.websocket\n    // this.programDir\n\n    this.init = this.init.bind(this)\n    this.getSocket = this.getSocket.bind(this)\n    this.emitPageData = this.emitPageData.bind(this)\n    this.emitStaticQueryData = this.emitStaticQueryData.bind(this)\n    this.emitError = this.emitError.bind(this)\n  }\n\n  init({ server, directory }) {\n    this.programDir = directory\n\n    const cachedStaticQueryResults = getCachedStaticQueryResults(\n      this.staticQueryResults,\n      this.programDir\n    )\n    this.staticQueryResults = new Map([\n      ...this.staticQueryResults,\n      ...cachedStaticQueryResults,\n    ])\n\n    this.websocket = require(`socket.io`)(server)\n\n    this.websocket.on(`connection`, s => {\n      let activePath = null\n      // Send already existing static query results\n      this.staticQueryResults.forEach(result => {\n        this.websocket.send({\n          type: `staticQueryResult`,\n          payload: result,\n        })\n      })\n      this.errors.forEach((message, errorID) => {\n        this.websocket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      const leaveRoom = path => {\n        s.leave(getRoomNameFromPath(path))\n        const leftRoom = this.websocket.sockets.adapter.rooms[\n          getRoomNameFromPath(path)\n        ]\n        if (!leftRoom || leftRoom.length === 0) {\n          this.activePaths.delete(path)\n        }\n      }\n\n      const getDataForPath = async path => {\n        if (!this.pageResults.has(path)) {\n          const result = await getCachedPageData(path, this.programDir)\n          if (result) {\n            this.pageResults.set(path, result)\n          } else {\n            console.log(`Page not found`, path)\n            return\n          }\n        }\n\n        this.websocket.send({\n          type: `pageQueryResult`,\n          why: `getDataForPath`,\n          payload: this.pageResults.get(path),\n        })\n      }\n\n      s.on(`getDataForPath`, getDataForPath)\n\n      s.on(`registerPath`, path => {\n        s.join(getRoomNameFromPath(path))\n        activePath = path\n        this.activePaths.add(path)\n      })\n\n      s.on(`disconnect`, s => {\n        leaveRoom(activePath)\n      })\n\n      s.on(`unregisterPath`, path => {\n        leaveRoom(path)\n      })\n    })\n\n    this.isInitialised = true\n  }\n\n  getSocket() {\n    return this.isInitialised && this.websocket\n  }\n\n  emitStaticQueryData(data: QueryResult) {\n    this.staticQueryResults.set(data.id, data)\n    if (this.isInitialised) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n    }\n  }\n\n  emitPageData(data: QueryResult) {\n    this.pageResults.set(data.id, data)\n    if (this.isInitialised) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n    }\n  }\n  emitError(id: string, message?: string) {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.isInitialised) {\n      this.websocket.send({ type: `overlayError`, payload: { id, message } })\n    }\n  }\n}\n\nconst manager = new WebsocketManager()\n\nmodule.exports = manager\n"],"file":"websocket-manager.js"}