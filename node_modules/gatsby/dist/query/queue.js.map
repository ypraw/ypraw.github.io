{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","FastMemoryStore","queryRunner","websocketManager","createBaseOptions","concurrent","store","createBuildQueue","handler","queryJob","callback","then","result","catch","createDevelopQueue","queue","processing","Set","waiting","Map","queueOptions","priority","job","cb","activePaths","Array","from","values","id","includes","merge","oldTask","newTask","filter","has","set","isPage","emitPageData","emitStaticQueryData","delete","push","get","error","pushJob","Promise","resolve","reject","on","processBatch","jobs","numJobs","length","runningJobs","map","all","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst queryRunner = require(`../query/query-runner`)\nconst websocketManager = require(`../utils/websocket-manager`)\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: 4,\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = () => {\n  const handler = (queryJob, callback) =>\n    queryRunner(queryJob)\n      .then(result => callback(null, result))\n      .catch(callback)\n  return new Queue(handler, createBaseOptions())\n}\n\nconst createDevelopQueue = () => {\n  let queue\n  const processing = new Set()\n  const waiting = new Map()\n\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: (job, cb) => {\n      const activePaths = Array.from(websocketManager.activePaths.values())\n      if (job.id && activePaths.includes(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n    // Filter out new query jobs if that query is already running.\n    // When the query finshes, it checks the waiting map and pushes\n    // another job to make sure all the user changes are captured.\n    filter: (job, cb) => {\n      if (processing.has(job.id)) {\n        waiting.set(job.id, job)\n        cb(`already running`)\n      } else {\n        cb(null, job)\n      }\n    },\n  }\n\n  const handler = (queryJob, callback) => {\n    queryRunner(queryJob).then(\n      result => {\n        if (queryJob.isPage) {\n          websocketManager.emitPageData({\n            result,\n            id: queryJob.id,\n          })\n        } else {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        processing.delete(queryJob.id)\n        if (waiting.has(queryJob.id)) {\n          queue.push(waiting.get(queryJob.id))\n          waiting.delete(queryJob.id)\n        }\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  queue = new Queue(handler, queueOptions)\n  return queue\n}\n\nconst pushJob = (queue, job) =>\n  new Promise((resolve, reject) =>\n    queue\n      .push(job)\n      .on(`finish`, resolve)\n      .on(`failed`, reject)\n  )\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n */\nconst processBatch = async (queue, jobs) => {\n  let numJobs = jobs.length\n  if (numJobs === 0) {\n    return Promise.resolve()\n  }\n  const runningJobs = jobs.map(job => pushJob(queue, job))\n  return await Promise.all(runningJobs)\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}