{"version":3,"sources":["../../../src/db/loki/index.js"],"names":["_","require","fs","path","loki","uuidv4","customComparators","Comparators","lt","ltHelper","gt","gtHelper","colls","nodeMeta","name","options","unique","indices","nodeTypes","db","ensureNodeCollections","forEach","collInfo","addCollection","startFileDb","saveFile","Promise","resolve","reject","dbOptions","autoload","autoloadCallback","err","startInMemory","start","isString","Error","saveDir","dirname","ensureDir","saveState","saveDatabase","getDb","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst fs = require(`fs-extra`)\nconst path = require(`path`)\nconst loki = require(`@stefanprobst/lokijs`)\nconst uuidv4 = require(`uuid/v4`)\nconst customComparators = require(`./custom-comparators`)\n\n// Ensure sorting behavior matches old lodash `orderBy`\n// implementation. See `custom-comparators.js` for why.\nloki.Comparators.lt = customComparators.ltHelper\nloki.Comparators.gt = customComparators.gtHelper\n\n// Loki is a document store with the same semantics as mongo. This\n// means there are no tables or relationships. Just a bunch of\n// collections, each with objects.\n//\n// Gatsby stores nodes in collections by splitting them up by their\n// `node.internal.type`. All nodes of a particular type go in 1\n// collection. The below `colls` object contains the metadata for\n// these collections, and the \"meta collections\" used to track them.\n//\n// You won't use these directly. They are used by the collection\n// functions in `./nodes.js`. E.g `getTypeCollName()` and\n// `getNodeTypeCollection`\nconst colls = {\n  // Each object has keys `id` and `typeCollName`. It's a way of\n  // quickly looking up the collection that a node is contained in.\n  // E.g { id: `someNodeId`, typeCollName: `gatsby:nodeType:myType` }\n  nodeMeta: {\n    name: `gatsby:nodeMeta`,\n    options: {\n      unique: [`id`],\n      indices: [`id`],\n    },\n  },\n  // The list of all node type collections. Each object has keys\n  // `type` and `collName` so you can quickly look up the collection\n  // name for a node type.\n  // e.g { type: `myType`, collName: `gatsby:nodeType:myType` }\n  nodeTypes: {\n    name: `gatsby:nodeTypes`,\n    options: {\n      unique: [`type`, `collName`],\n      indices: [`type`],\n    },\n  },\n}\n\n// Must be set using `start()`\nlet db\n\n/**\n * Ensures that the collections that support nodes have been\n * created. See `colls` var in this file\n */\nfunction ensureNodeCollections(db) {\n  _.forEach(colls, collInfo => {\n    const { name, options } = collInfo\n    db.addCollection(name, options)\n  })\n}\n\nfunction startFileDb(saveFile) {\n  return new Promise((resolve, reject) => {\n    const dbOptions = {\n      autoload: true,\n      autoloadCallback: err => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve()\n        }\n      },\n    }\n    db = new loki(saveFile, dbOptions)\n  })\n}\n\nasync function startInMemory() {\n  // Use uuid purely for a random name\n  db = new loki(uuidv4())\n}\n\n/**\n * Starts a loki database. If the file already exists, it will be\n * loaded as the database state. If not, a new database will be\n * created. If `saveFile` is omitted, an in-memory DB will be created.\n *\n * @param {string} saveFile on disk file that the database will be\n * saved and loaded from. If this is omitted, an in-memory database\n * will be created instead\n * @returns {Promise} promise that is resolved once the database and\n * the existing state has been loaded (if there was an existing\n * saveFile)\n */\nasync function start({ saveFile } = {}) {\n  if (saveFile && !_.isString(saveFile)) {\n    throw new Error(`saveFile must be a path`)\n  }\n  if (saveFile) {\n    const saveDir = path.dirname(saveFile)\n    await fs.ensureDir(saveDir)\n    await startFileDb(saveFile)\n  } else {\n    await startInMemory()\n  }\n  ensureNodeCollections(db)\n}\n\n// Saves the database to disk and returns a promise that will be\n// resolved once the save has finished\nfunction saveState() {\n  return new Promise((resolve, reject) => {\n    if (db) {\n      db.saveDatabase(err => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve()\n        }\n      })\n    } else {\n      reject(`No database found.`)\n    }\n  })\n}\n\n/**\n * Returns a reference to the database. If undefined, the db has not been\n * initalized yet. Call `start()`\n *\n * @returns {Object} database, or undefined\n */\nfunction getDb() {\n  return db\n}\n\nmodule.exports = {\n  start,\n  getDb,\n  colls,\n  saveState,\n}\n"],"file":"index.js"}