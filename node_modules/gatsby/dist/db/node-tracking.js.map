{"version":3,"sources":["../../src/db/node-tracking.js"],"names":["_","require","rootNodeMap","WeakMap","getRootNodeId","node","get","omitUndefined","data","isPlainObject","pickBy","p","undefined","filter","isTypeSupported","type","isSupported","Date","addRootNodeToInlineObject","nodeId","sanitize","isNode","isArray","returnData","anyFieldChanged","each","o","key","set","trackInlineObjectsInRootNode","id","exports","findRootNodeAncestor","obj","predicate","getNode","rootNode","whileCount","rootNodeId","parent","console","log","trackDbNodes","getNodes"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\n\n/**\n * Map containing links between inline objects or arrays\n * and Node that contains them\n * @type {Object.<(Object|Array),string>}\n */\nconst rootNodeMap = new WeakMap()\n\nconst getRootNodeId = node => rootNodeMap.get(node)\n\n/**\n * @param {Object} data\n * @returns {Object} data without undefined values\n */\nconst omitUndefined = data => {\n  const isPlainObject = _.isPlainObject(data)\n  if (isPlainObject) {\n    return _.pickBy(data, p => p !== undefined)\n  }\n\n  return data.filter(p => p !== undefined)\n}\n\n/**\n * @param {*} data\n * @return {boolean}\n */\nconst isTypeSupported = data => {\n  if (data === null) {\n    return true\n  }\n\n  const type = typeof data\n  const isSupported =\n    type === `number` ||\n    type === `string` ||\n    type === `boolean` ||\n    data instanceof Date\n\n  return isSupported\n}\n\n/**\n * Add link between passed data and Node. This function shouldn't be used\n * directly. Use higher level `trackInlineObjectsInRootNode`\n * @see trackInlineObjectsInRootNode\n * @param {(Object|Array)} data Inline object or array\n * @param {string} nodeId Id of node that contains data passed in first parameter\n * @param {boolean} sanitize Wether to strip objects of unuspported and not serializable fields\n * @param {string} [ignore] Fieldname that doesn't need to be tracked and sanitized\n *\n */\nconst addRootNodeToInlineObject = (data, nodeId, sanitize, isNode = false) => {\n  const isPlainObject = _.isPlainObject(data)\n\n  if (isPlainObject || _.isArray(data)) {\n    let returnData = data\n    if (sanitize) {\n      returnData = isPlainObject ? {} : []\n    }\n    let anyFieldChanged = false\n    _.each(data, (o, key) => {\n      if (isNode && key === `internal`) {\n        returnData[key] = o\n        return\n      }\n      returnData[key] = addRootNodeToInlineObject(o, nodeId, sanitize)\n\n      if (returnData[key] !== o) {\n        anyFieldChanged = true\n      }\n    })\n\n    if (anyFieldChanged) {\n      data = omitUndefined(returnData)\n    }\n\n    // don't need to track node itself\n    if (!isNode) {\n      rootNodeMap.set(data, nodeId)\n    }\n\n    // arrays and plain objects are supported - no need to to sanitize\n    return data\n  }\n\n  if (sanitize && !isTypeSupported(data)) {\n    return undefined\n  }\n  // either supported or not sanitizing\n  return data\n}\n\n/**\n * Adds link between inline objects/arrays contained in Node object\n * and that Node object.\n * @param {Node} node Root Node\n */\nconst trackInlineObjectsInRootNode = (node, sanitize = false) =>\n  addRootNodeToInlineObject(node, node.id, sanitize, true)\nexports.trackInlineObjectsInRootNode = trackInlineObjectsInRootNode\n\n/**\n * Finds top most ancestor of node that contains passed Object or Array\n * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object\n * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions\n * @returns {Node} Top most ancestor if predicate is not specified\n * or first node that meet predicate conditions if predicate is specified\n */\nconst findRootNodeAncestor = (obj, predicate = null) => {\n  const { getNode } = require(`./nodes`)\n\n  // Find the root node.\n  let rootNode = obj\n  let whileCount = 0\n  let rootNodeId\n  while (\n    (!predicate || !predicate(rootNode)) &&\n    (rootNodeId = getRootNodeId(rootNode) || rootNode.parent) &&\n    ((rootNode.parent && getNode(rootNode.parent) !== undefined) ||\n      getNode(rootNodeId)) &&\n    whileCount < 101\n  ) {\n    if (rootNodeId) {\n      rootNode = getNode(rootNodeId)\n    } else {\n      rootNode = getNode(rootNode.parent)\n    }\n    whileCount += 1\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n  }\n\n  return !predicate || predicate(rootNode) ? rootNode : null\n}\n\nfunction trackDbNodes() {\n  const { getNodes } = require(`./nodes`)\n  _.each(getNodes(), node => {\n    trackInlineObjectsInRootNode(node)\n  })\n}\n\n/**\n * @callback nodePredicate\n * @param {Node} node Node that is examined\n */\nexports.findRootNodeAncestor = findRootNodeAncestor\nexports.trackDbNodes = trackDbNodes\n"],"file":"node-tracking.js"}