{"version":3,"sources":["../../../src/db/common/query.js"],"names":["_","require","getNamedType","getQueryFields","filter","sort","group","distinct","filterFields","dropQueryOperators","sortFields","fields","Array","isArray","merge","map","pathToObject","mergeObjects","obj1","obj2","Object","keys","reduce","acc","key","value","objects","Boolean","first","rest","obj","path","split","reduceRight","k","v","isPlainObject","hasFieldResolvers","type","getFields","some","fieldName","filterValue","field","resolve","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst { getNamedType } = require(`graphql`)\n\nconst getQueryFields = ({ filter, sort, group, distinct }) => {\n  const filterFields = filter ? dropQueryOperators(filter) : {}\n  const sortFields = (sort && sort.fields) || []\n\n  if (group && !Array.isArray(group)) {\n    group = [group]\n  } else if (group == null) {\n    group = []\n  }\n\n  if (distinct && !Array.isArray(distinct)) {\n    distinct = [distinct]\n  } else if (distinct == null) {\n    distinct = []\n  }\n\n  return merge(\n    filterFields,\n    ...sortFields.map(pathToObject),\n    ...group.map(pathToObject),\n    ...distinct.map(pathToObject)\n  )\n}\n\nconst mergeObjects = (obj1, obj2) =>\n  Object.keys(obj2).reduce((acc, key) => {\n    const value = obj2[key]\n    if (typeof value === `object` && value && acc[key]) {\n      acc[key] = mergeObjects(acc[key], value)\n    } else {\n      acc[key] = value\n    }\n    return acc\n  }, obj1)\n\nconst merge = (...objects) => {\n  const [first, ...rest] = objects.filter(Boolean)\n  return rest.reduce((acc, obj) => mergeObjects(acc, obj), { ...first })\n}\n\nconst pathToObject = path => {\n  if (path && typeof path === `string`) {\n    return path.split(`.`).reduceRight((acc, key) => {\n      return { [key]: acc }\n    }, true)\n  }\n  return {}\n}\n\nconst dropQueryOperators = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    const value = filter[key]\n    const k = Object.keys(value)[0]\n    const v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? dropQueryOperators(v) : dropQueryOperators(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\nconst hasFieldResolvers = (type, filterFields) => {\n  const fields = type.getFields()\n  return Object.keys(filterFields).some(fieldName => {\n    const filterValue = filterFields[fieldName]\n    const field = fields[fieldName]\n    return (\n      Boolean(field.resolve) ||\n      (filterValue !== true &&\n        hasFieldResolvers(getNamedType(field.type), filterValue))\n    )\n  })\n}\n\nmodule.exports = {\n  dropQueryOperators,\n  getQueryFields,\n  hasFieldResolvers,\n}\n"],"file":"query.js"}