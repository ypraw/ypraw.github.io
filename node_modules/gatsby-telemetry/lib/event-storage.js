"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const os = require(`os`);

const path = require(`path`);

const Store = require(`./store`);

const fetch = require(`node-fetch`);

const Configstore = require(`configstore`);

const _require = require(`fs-extra`),
      ensureDirSync = _require.ensureDirSync;

const isTruthy = require(`./is-truthy`);
/* The events data collection is a spooled process that
 * buffers events to a local fs based buffer
 * which then is asynchronously flushed to the server.
 * This both increases the fault tolerancy and allows collection
 * to continue even when working offline.
 */


module.exports = class EventStorage {
  constructor() {
    try {
      this.config = new Configstore(`gatsby`, {}, {
        globalConfigPath: true
      });
    } catch (e) {
      // This should never happen
      this.config = {
        get: key => this.config[key],
        set: (key, value) => this.config[key] = value,
        all: this.config,
        path: path.join(os.tmpdir(), `gatsby`),
        "telemetry.enabled": true,
        "telemetry.machineId": `not-a-machine-id`
      };
    }

    const baseDir = path.dirname(this.config.path);

    try {
      ensureDirSync(baseDir);
    } catch (e) {// TODO: Log this event
    }

    this.store = new Store(baseDir);
    this.verbose = isTruthy(process.env.GATSBY_TELEMETRY_VERBOSE);
    this.debugEvents = isTruthy(process.env.GATSBY_TELEMETRY_DEBUG);
    this.disabled = isTruthy(process.env.GATSBY_TELEMETRY_DISABLED);
  }

  addEvent(event) {
    if (this.disabled) {
      return;
    }

    const eventString = JSON.stringify(event);

    if (this.debugEvents || this.verbose) {
      console.error(`Captured event:`, eventString);

      if (this.debugEvents) {
        // Bail because we don't want to send debug events
        return;
      }
    }

    this.store.appendToBuffer(eventString + `\n`);
  }

  sendEvents() {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      return _this.store.startFlushEvents(
      /*#__PURE__*/
      function () {
        var _ref = (0, _asyncToGenerator2.default)(function* (eventsData) {
          const events = eventsData.split(`\n`).filter(e => e && e.length > 2) // drop empty lines
          .map(e => JSON.parse(e));
          return _this.submitEvents(events);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    })();
  }

  submitEvents(events) {
    return (0, _asyncToGenerator2.default)(function* () {
      try {
        const res = yield fetch(`https://analytics.gatsbyjs.com/events`, {
          method: `POST`,
          headers: {
            "content-type": `application/json`
          },
          body: JSON.stringify(events)
        });
        return res.ok;
      } catch (e) {
        return false;
      }
    })();
  }

  getConfig(key) {
    if (key) {
      return this.config.get(key);
    }

    return this.config.all;
  }

  updateConfig(key, value) {
    return this.config.set(key, value);
  }

};