'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.insertScript = insertScript;
exports.removeScript = removeScript;
exports.debounce = debounce;
exports.isReactElement = isReactElement;
exports.shallowComparison = shallowComparison;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function insertScript(src, id, parentElement) {
    var script = window.document.createElement('script');
    script.async = true;
    script.src = src;
    script.id = id;
    parentElement.appendChild(script);

    return script;
}

function removeScript(id, parentElement) {
    var script = window.document.getElementById(id);
    if (script) parentElement.removeChild(script);
}

function debounce(func, wait, runOnFirstCall) {
    var timeout = void 0;
    return function () {
        var context = this; // eslint-disable-line consistent-this
        var args = arguments;

        var deferredExecution = function deferredExecution() {
            timeout = null;
            if (!runOnFirstCall) func.apply(context, args);
        };

        var callNow = runOnFirstCall && !timeout;

        window.clearTimeout(timeout);
        timeout = setTimeout(deferredExecution, wait);

        if (callNow) func.apply(context, args);
    };
}

function isReactElement(element) {
    if (_react2.default.isValidElement(element)) {
        return true;
    } else if (Array.isArray(element)) {
        return element.some(function (value) {
            return _react2.default.isValidElement(value);
        });
    }
    return false;
}

function shallowComparison(currentProps, nextProps) {
    // Perform a comparison of all props, excluding React Elements, to prevent unnecessary updates
    var propNames = new Set(Object.keys(currentProps), Object.keys(nextProps)); // eslint-disable-line no-undef
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var name = _step.value;

            if (currentProps[name] !== nextProps[name] && !isReactElement(currentProps[name])) return true;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return false;
}