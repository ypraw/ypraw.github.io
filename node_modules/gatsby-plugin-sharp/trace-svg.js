"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _require = require(`bluebird`),
      promisify = _require.promisify;

const crypto = require(`crypto`);

const _ = require(`lodash`);

const tmpDir = require(`os`).tmpdir();

const sharp = require(`./safe-sharp`);

const duotone = require(`./duotone`);

const _require2 = require(`./plugin-options`),
      getPluginOptions = _require2.getPluginOptions,
      healOptions = _require2.healOptions;

const _require3 = require(`./report-error`),
      reportError = _require3.reportError;

exports.notMemoizedPrepareTraceSVGInputFile =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    file,
    options,
    tmpFilePath,
    reporter
  }) {
    let pipeline;

    try {
      pipeline = sharp(file.absolutePath);

      if (!options.rotate) {
        pipeline.rotate();
      }
    } catch (err) {
      reportError(`Failed to process image ${file.absolutePath}`, err, reporter);
      return;
    }

    pipeline.resize(options.width, options.height, {
      position: options.cropFocus
    }).png({
      compressionLevel: options.pngCompressionLevel,
      adaptiveFiltering: false,
      force: options.toFormat === `png`
    }).jpeg({
      quality: options.quality,
      progressive: options.jpegProgressive,
      force: options.toFormat === `jpg`
    }); // grayscale

    if (options.grayscale) {
      pipeline = pipeline.grayscale();
    } // rotate


    if (options.rotate && options.rotate !== 0) {
      pipeline = pipeline.rotate(options.rotate);
    } // duotone


    if (options.duotone) {
      pipeline = yield duotone(options.duotone, options.toFormat, pipeline);
    }

    yield new Promise((resolve, reject) => pipeline.toFile(tmpFilePath, err => {
      if (err) {
        return reject(err);
      }

      return resolve();
    }));
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

const optimize = svg => {
  const SVGO = require(`svgo`);

  const svgo = new SVGO({
    multipass: true,
    floatPrecision: 0
  });
  return svgo.optimize(svg).then(({
    data
  }) => data);
};

exports.notMemoizedtraceSVG =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* ({
    file,
    args,
    fileArgs,
    reporter
  }) {
    const options = healOptions(getPluginOptions(), Object.assign({}, fileArgs && fileArgs.maxWidth && fileArgs.maxHeight ? {
      height: fileArgs.maxHeight,
      width: fileArgs.maxWidth
    } : {}, fileArgs), file.extension);
    const tmpFilePath = `${tmpDir}/${file.internal.contentDigest}-${file.name}-${crypto.createHash(`md5`).update(JSON.stringify(options)).digest(`hex`)}.${file.extension}`;

    try {
      yield exports.memoizedPrepareTraceSVGInputFile({
        tmpFilePath,
        file,
        options,
        reporter
      });

      const svgToMiniDataURI = require(`mini-svg-data-uri`);

      const potrace = require(`potrace`);

      const trace = promisify(potrace.trace);
      const defaultArgs = {
        color: `lightgray`,
        optTolerance: 0.4,
        turdSize: 100,
        turnPolicy: potrace.Potrace.TURNPOLICY_MAJORITY
      };

      const optionsSVG = _.defaults(args, defaultArgs);

      return trace(tmpFilePath, optionsSVG).then(optimize).then(svgToMiniDataURI);
    } catch (e) {
      throw e;
    }
  });

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();

let memoizedPrepareTraceSVGInputFile, memoizedTraceSVG;

const createMemoizedFunctions = () => {
  exports.memoizedPrepareTraceSVGInputFile = memoizedPrepareTraceSVGInputFile = _.memoize(exports.notMemoizedPrepareTraceSVGInputFile, ({
    tmpFilePath
  }) => tmpFilePath);
  exports.memoizedTraceSVG = memoizedTraceSVG = _.memoize(exports.notMemoizedtraceSVG, ({
    file,
    args,
    fileArgs
  }) => `${file.internal.contentDigest}${JSON.stringify(args)}${JSON.stringify(fileArgs)}`);
}; // This is very hacky, but memozied function are pretty tricky to spy on
// in tests ;(


createMemoizedFunctions();

exports.createMemoizedFunctions = () => {
  createMemoizedFunctions();
};

exports.clearMemoizeCaches = () => {
  memoizedTraceSVG.cache.clear();
  memoizedPrepareTraceSVGInputFile.cache.clear();
};